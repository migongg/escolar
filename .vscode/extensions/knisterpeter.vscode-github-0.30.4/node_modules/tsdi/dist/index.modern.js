import"reflect-metadata";const t=(()=>{const t=t=>-1!==(t||"").indexOf("tsdi")||"*"===t;return"object"==typeof exports&&"undefined"!=typeof module?t(process.env.DEBUG):"undefined"!=typeof window&&t(window.localStorage.getItem("DEBUG"))})(),e=e=>{const n=(e,...n)=>{if(!t)return;if(e instanceof Error)return void console.error(e);const o=[];let r=0,i=0,s=e.indexOf("%",i);for(;-1!==s;){switch(o.push(e.substring(i,s)),e.substr(s,2)){case"%o":o.push(n[r++]);break;case"%s":o.push(String(n[r++]))}i=s+2,s=e.indexOf("%",i)}i<e.length&&o.push(e.substring(i)),console.log(...o)};return n.enabled=t,n};function n(t){return Boolean(t.rtti)}function o(t,e){let n=-1;for(let o=0,r=t.length;o<r;o++)e(t[o])&&(n=o);return n}function r(t){return"string"==typeof t?{name:t}:t}let i=[];const s=[],a=[];function c(t){if(t.options.name&&o(s,e=>e.options.name===t.options.name)>-1)throw new Error(`Duplicate name '${t.options.name}' for known Components.`);s.push(t),i.forEach(e=>e(t))}const p=e();function d(...t){const e=(t,e={})=>{p("@Component "+t.name);const n=r(e);return c({fn:t,options:n}),Reflect.defineMetadata("component:options",n,t),t};return 1===t.length&&"function"==typeof t[0]?e(t[0],{}):function(n){return e(n,t[0]||{})}}const m=d,h=e();function f(...t){const e=(t,e)=>{h("@Destroy %s#%s",t.constructor.name,e),Reflect.defineMetadata("component:destroy",e,t)};return t.length>0?e(t[0],t[1]):function(t,n){e(t,n)}}const l=f,y=e();function u(...t){const e=t=>{y("@External "+t.name),function(t){-1===o(a,e=>e===t)&&(a.push(t),i.forEach(e=>e(t)))}(t);const e=function(...e){return t.__tsdi__.configureExternal(e,t)};return e.displayName=t.name,Object.getOwnPropertyNames(t).filter(t=>"name"!==t&&"length"!==t&&"caller"!==t&&"callee"!==t&&"arguments"!==t&&!e[t]).forEach(n=>e[n]=t[n]),e.prototype=t.prototype,e};return t.length>0?e(t[0]):function(t){return e(t)}}const g=u,I=e();function C(...t){const e=(t,e,n)=>{I.enabled&&I('@Factory %s#%s({name: "%s"})',t.constructor.name,e,t[e].name),c({target:t,property:e.toString(),options:n,rtti:Reflect.getMetadata("design:returntype",t,e)})};if(t.length>1)return e(t[0],t[1],{});const n=t[0]||{};return function(t,o){e(t,o,n)}}const M=C,w=e();function j(...t){const e=(t,e)=>{w("@Initialize %s#%s",t.constructor.name,e),Reflect.defineMetadata("component:init",e,t);const n=Reflect.getMetadata("design:returntype",t,e)===Promise;Reflect.defineMetadata("component:init:async",n,t)};return t.length>0?e(t[0],t[1]):function(t,n){e(t,n)}}const O=j,b=e();function E(...t){const e=t=>{const e=r(t||{});return void 0===e.lazy&&(e.lazy=!0),e},n=(t,e,n)=>{b(`@Inject ${t.constructor.name}#${String(e)}`);const o=Reflect.getMetadata("design:type",t,e);let r=Reflect.getMetadata("component:injects",t);r||(r=[],Reflect.defineMetadata("component:injects",r,t)),r.push({target:t,property:e.toString(),options:n,type:o})},o=(t,e,n,o)=>{b("@Inject "+String(e));let r=Reflect.getMetadata("component:parameters",t);r||(r=[],Reflect.defineMetadata("component:parameters",r,t)),r.push({options:o,index:n,rtti:Reflect.getMetadata("design:paramtypes",t)[n]})};if(!(t.length>1))return function(r,i,s){const a=e(t[0]||{});return void 0===s?n(r,i,a):o(r,i,s,a)};{const r=e({});void 0===t[2]?n(t[0],t[1],r):o(t[0],t[1],t[2],r)}}const z=E,R=e();class k{constructor(){this.autoMock=void 0,this.components=[],this.instances={},this.properties={},this.lifecycleListeners=[],this.scopes={},this.registerComponent({fn:k,options:{}}),this.instances[0]=this}addLifecycleListener(t){this.lifecycleListeners.push(t),Object.keys(this.instances).forEach(t=>{this.notifyOnCreate(this.instances[parseInt(t,10)])})}notifyOnCreate(t){this.lifecycleListeners.forEach(e=>{e.onCreate&&e.onCreate(t)})}notifyOnDestroy(t){this.lifecycleListeners.forEach(e=>{e.onDestroy&&e.onDestroy(t)})}addProperty(t,e){this.properties[t]=e}close(){var t;Object.keys(this.instances).forEach(t=>{const e=parseInt(t,10),o=this.components[e];n(o)||this.destroyInstance(e,o)}),this.instances=[],this.listener&&(t=this.listener,i=function(e,n){const r=o(e,e=>e===t);return r>-1?[...e.slice(0,r),...e.slice(r+1)]:e}(i),this.listener=void 0)}destroyInstance(t,e){const o=this.instances[t];if(o){this.notifyOnDestroy(o);const r=Reflect.getMetadata("component:destroy",n(e)?e.rtti:e.fn.prototype);r&&o[r]&&o[r].call(o),this.instances[t]=void 0}}enableComponentScanner(){var t;this.listener||(this.listener=t=>{"function"==typeof t?t.__tsdi__=this:this.registerComponent(t)},this.listener&&(i.push(t=this.listener),s.forEach(e=>t(e)),a.forEach(e=>t(e))))}enableAutomock(...t){console.warn("#enableAutomock is deprecated and should not be used. Instead use #override."),this.autoMock=t}registerComponent(t){if(-1===this.components.indexOf(t)&&(t.options.name&&o(this.components,e=>e.options.name===t.options.name)>-1&&console.warn(`Component with name '${t.options.name}' already registered.`),this.markAsyncInitializer(t),R("registerComponent %o",n(t)?t.rtti.name:t.fn.name),this.components.push(t),t.options.eager)){const e=this.components.length-1;setTimeout(()=>{this.getOrCreate(t,e)},0)}}markAsyncInitializer(t){if(n(t)){const e=Reflect.getMetadata("component:init:async",t.target.constructor.prototype);Reflect.defineMetadata("component:init:async",e,t.rtti.prototype)}else{const e=Reflect.getMetadata("component:init:async",t.fn.prototype),n=(Reflect.getMetadata("component:injects",t.fn.prototype)||[]).some(t=>t.type&&Reflect.getMetadata("component:init:async",t.type.prototype));!e&&n&&Reflect.defineMetadata("component:init:async",!0,t.fn.prototype)}}register(t,e){const n=Reflect.getMetadata("component:options",t)||{};this.registerComponent({fn:t,options:{...n,name:e||n.name}})}getComponentMetadataIndex(t,e){for(let n=0,o=this.components.length;n<o;n++)if(e){if(e===this.components[n].options.name)return n}else if(this.isComponentMetadataIndexFromComponentOrFactory(t,this.components[n]))return n;return-1}isComponentMetadataIndexFromComponentOrFactory(t,e){return void 0!==t&&(e.fn===t||n(e)&&e.rtti===t)}throwComponentNotFoundError(t,e,n){throw t&&!e&&(e=t.name),e||(e="unknown"),new Error(`Component '${e}' not found${n?": "+n:""}`)}getConstructorParameters(t){const e=Reflect.getMetadata("component:parameters",t.fn);return e?e.sort((t,e)=>t.index-e.index).map(t=>({index:this.getComponentMetadataIndex(t.rtti,t.options.name)})).map(({index:t})=>this.getOrCreate(this.components[t],t)):[]}isSingleton(t){return void 0===t.options.singleton||t.options.singleton}getOrCreateFactory(t){return this.get(t.target.constructor)}hasAsyncFactoryInitializer(t){const e=this.getOrCreateFactory(t),n=this.getInitializerPromise(e);return Boolean(n)}getOrCreate(t,e){R("> getOrCreate %o",t);let o=this.instances[e];return o&&this.isSingleton(t)||(n(t)?(R("create %o from factory with %o",t.rtti.name,t.options),o=this.getOrCreateFactory(t)[t.property](),this.instances[e]=o):o=this.createComponent(t,e),this.notifyOnCreate(o)),R("< getOrCreate %o -> %o",t,o),o}addInitializerPromise(t,e){e&&Reflect.defineMetadata("tsdi:initialize:promise",e,t)}getInitializerPromise(t){return Reflect.getMetadata("tsdi:initialize:promise",t)}createComponent(t,e){this.hasEnteredScope(t)||this.throwComponentNotFoundError(t.fn,void 0,`required scope '${t.options.scope}' is not enabled`),R("create %o with %o",t.fn.name,t.options);const n=new(0,t.fn)(...this.getConstructorParameters(t));this.instances[e]=n,this.injectIntoInstance(n,!1,t);const o=Reflect.getMetadata("component:init",t.fn.prototype);return this.maybeLazyInitialize(n,o,t),n}waitForInjectInitializers(t){const e=Reflect.getMetadata("component:injects",t.fn.prototype);if(e&&e.some(t=>Reflect.getMetadata("component:init:async",t.type.prototype)))return Promise.all(e.map(t=>{const[e,o]=this.getInjectComponentMetadata(t),r=n(e)?this.getOrCreateFactory(e):this.getOrCreate(e,o);return this.getInitializerPromise(r)}))}hasEnteredScope(t){return!t.options.scope||Boolean(t.options.scope&&this.scopes[t.options.scope])}configureExternal(t,e){const n={fn:e,options:{}},o=new e(...t,...this.getConstructorParameters({fn:e,options:{}}));this.injectIntoInstance(o,!0,n);const r=Reflect.getMetadata("component:init",e.prototype);return this.maybeLazyInitialize(o,r,n),o}maybeLazyInitialize(t,e,n){const o=this.waitForInjectInitializers(n);e?this.addInitializerPromise(t,o?o.then(()=>t[e].call(t)||Promise.resolve()):t[e].call(t)):o&&this.addInitializerPromise(t,o)}injectIntoInstance(t,e,n){const o=Reflect.getMetadata("component:injects",n.fn.prototype);if(o)for(const r of o)R("injecting %s.%s",t.constructor.name,r.property),r.options.name&&void 0!==this.properties[r.options.name]?t[r.property]=this.properties[r.options.name]:this.injectDependency(t,e,r,n)}injectDependency(t,e,n,o){if(!this.injectAutoMock(t,n))if(this.isAsyncInitializerDependency(n)||!n.options.lazy&&!n.options.dynamic)this.isAsyncFactoryInjection(n)?this.createAsyncFactoryInjection(t,n):t[n.property]=this.getComponentDependency(n,o,e);else{const r=this;Object.defineProperty(t,n.property,{configurable:!0,enumerable:!0,get(){R("lazy-resolve injected property %s.%s",t.constructor.name,n.property);const i=r.getComponentDependency(n,o,e);return n.options.dynamic?i:(Object.defineProperty(t,n.property,{enumerable:!0,value:i}),R("lazy-resolved injected property %s.%s <- %o",t.constructor.name,n.property,t[n.property]),t[n.property])}})}}createAsyncFactoryInjection(t,e){const[o]=this.getInjectComponentMetadata(e);if(!n(o))throw new Error("Illegal state: async factory injection without factory metadata");const r=this.getOrCreateFactory(o),i=this.getInitializerPromise(r);let s=!1;i&&i.then(()=>{s=!0}),Object.defineProperty(t,e.property,{configurable:!0,enumerable:!0,get(){if(s){const n=r[o.property]();return Object.defineProperty(t,e.property,{enumerable:!0,value:n}),n}throw new Error("Illegal state: need to wait for factory to resolve")}})}isAsyncFactoryInjection(t){const[e]=this.getInjectComponentMetadata(t);return!!n(e)&&this.hasAsyncFactoryInitializer(e)}isAsyncInitializerDependency(t){const[e]=this.getInjectComponentMetadata(t),o=n(e)?this.hasAsyncFactoryInitializer(e):Reflect.getMetadata("component:init:async",e.fn.prototype);if(o&&t.options.dynamic)throw new Error(`Injecting ${t.type.name} into ${t.target.constructor.name}#${t.property} must not be dynamic since ${t.type.name} has an async initializer`);return o}injectAutoMock(t,e){if(!this.autoMock)return!1;const[o]=this.getInjectComponentMetadata(e);if(o){const r=n(o)?o.rtti:o.fn;if(this.autoMock.indexOf(r)>-1)return!1;const i=this.mock(r);if(i)return t[e.property]=i,!0}return!1}createAutoMock(t){if(!this.autoMock||this.autoMock.indexOf(t)>-1)return;const e={__tsdi__mock__:"This is a TSDI automock"},n=t.prototype;return Object.getOwnPropertyNames(n).forEach(t=>{"function"==typeof n[t]&&(e[t]=function(...t){return t})}),e||void 0}mock(t){console.warn("#mock is deprecated and should not be used. Instead use #override.");const e=this.getComponentMetadataIndex(t);if(!this.instances[e]){const n=this.createAutoMock(t);if(!n)throw new Error("Failed to create mock from "+t.name);this.instances[e]=n}return this.instances[e]}getInjectComponentMetadata(t){let e=this.getComponentMetadataIndex(t.type,t.options.name);-1===e&&(this.checkAndThrowDependencyError(t),e=this.getComponentMetadataIndex(t.type,t.type.name));const n=this.components[e];if(!n)throw new Error(`Failed to get inject '${t.options.name}' for '${t.target.constructor.name}#${t.property}'`);return[n,e]}getComponentDependency(t,e,o){const[r,i]=this.getInjectComponentMetadata(t);return o||t.options.dynamic||n(r)||!r.options.scope||e.options.scope||console.warn(`Component '${r.fn.name}' is scoped to '${r.options.scope}' and injected into '${e.fn.name}' without scope. This could easily lead to stale references. Consider to add the scope '${r.options.scope}' to '${e.fn.name}' as well or make the inject dynamic.`),this.getOrCreate(r,i)}checkAndThrowDependencyError(t){if(t.type&&t.options.name){const e=new Error("Injecting undefined type on "+t.target.constructor.name+`#${t.property}: Component named '${t.options.name}' not found`);throw R(e),R("Known Components: %o",this.components.map(t=>n(t)?t.rtti.name:t.fn.name)),e}if(!t.type||t.options.name){const e=new Error("Injecting undefined type on "+t.target.constructor.name+`#${t.property}: Probably a cyclic dependency, switch to name based injection`);throw R(e),e}}get(t,e){let n;"string"==typeof t?(e=t,n=void 0):n=t;const o=this.getComponentMetadataIndex(n,e),r=this.components[o];return r||this.throwComponentNotFoundError(n,e),this.getOrCreate(r,o)}override(t,e){const n=this.getComponentMetadataIndex(t);this.instances[n]=e,R("Override %o with %o",t,e)}getScope(t){const e=this;return{enter(){e.scopes[t]=!0},leave(){delete e.scopes[t],e.components.filter(e=>!n(e)&&e.options.scope===t).forEach(t=>{const o=e.getComponentMetadataIndex(n(t)?t.rtti:t.fn);e.destroyInstance(o,t)})}}}}export{d as Component,f as Destroy,u as External,C as Factory,j as Initialize,E as Inject,k as TSDI,m as component,l as destroy,g as external,M as factory,O as initialize,z as inject};
//# sourceMappingURL=index.modern.js.map
